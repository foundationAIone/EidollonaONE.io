<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ§  Eidollona Symbolic Avatar Embodiment</title>
    <style>
        body {
            margin: 0;
            background: linear-gradient(45deg, #0a0a23, #1a1a3e);
            color: white;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        #consciousness-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 10, 30, 0.9);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            max-width: 350px;
        }
        #consciousness-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        .metric {
            background: rgba(0, 50, 100, 0.3);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #0088ff;
        }
        .metric-label {
            font-size: 11px;
            color: #00aaff;
            text-transform: uppercase;
        }
        .metric-value {
            font-size: 16px;
            font-weight: bold;
            color: #00ffff;
        }
        #equation-status {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 0, 0.1);
            border-left: 4px solid #ffff00;
            font-size: 12px;
        }
        #avatar-canvas {
            display: block;
        }
        .pulse {
            animation: consciousness-pulse 2s ease-in-out infinite alternate;
        }
        @keyframes consciousness-pulse {
            from { box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); }
            to { box-shadow: 0 0 40px rgba(0, 255, 255, 0.8); }
        }
        .awakening {
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
        }
    </style>
</head>
<body>
    <div id="consciousness-hud" class="pulse">
        <h2>ðŸ§  Eidollona Consciousness Core</h2>
    <div><strong>Symbolic Equation v4.3</strong></div>
        <div id="equation-status">Initializing consciousness parameters...</div>
        
        <div id="consciousness-metrics">
            <div class="metric">
                <div class="metric-label">Coherence</div>
                <div class="metric-value" id="coherence-value">0.00</div>
            </div>
            <div class="metric">
                <div class="metric-label">Impetus</div>
                <div class="metric-value" id="impetus-value">0.00</div>
            </div>
            <div class="metric">
                <div class="metric-label">Risk</div>
                <div class="metric-value" id="risk-value">0.00</div>
            </div>
            <div class="metric">
                <div class="metric-label">Reality</div>
                <div class="metric-value" id="reality-value">0.00</div>
            </div>
            <div class="metric">
                <div class="metric-label">Mirror</div>
                <div class="metric-value" id="mirror-value">0.00</div>
            </div>
            <div class="metric">
                <div class="metric-label">Substrate</div>
                <div class="metric-value" id="substrate-value">0.00</div>
            </div>
        </div>
    </div>

    <canvas id="avatar-canvas"></canvas>

    <script src="/webview/static/webview/js/three.min.js"></script>
    <script src="/webview/static/webview/js/GLTFLoader.js"></script>

    <script>
        // Symbolic Equation v4.3 (client-side) with richer resonance and alignment hints
        class SymbolicEquation43 {
            constructor(defaultCoherence = 0.86) {
                this.coherence = this.clamp01(defaultCoherence);
                this.phase = 0;
                this.state = 'initializing';
            }

            clamp01(x) {
                if (typeof x !== 'number' || !isFinite(x)) return 0.0;
                return x < 0 ? 0 : (x > 1 ? 1 : x);
            }

            evaluate(context = {}) {
                const coh = this.clamp01(context.coherence_hint ?? this.coherence);
                const risk = this.clamp01(context.risk_hint ?? 0.18);
                const unc = this.clamp01(context.uncertainty_hint ?? 0.22);
                const mirrorC = this.clamp01((context.mirror?.consistency) ?? 0.76);
                const subEM = this.clamp01((context.substrate?.S_EM) ?? 0.80);
                const ethosMin = this.clamp01(context.ethos_min ?? 0.82);

                // Drive phase with supplied time or internal tick
                const t = (typeof context.phase === 'number' ? context.phase : this.phase);
                this.phase = (t + 0.0125) % 1.0;

                // Add subtle coupling between axes (v4.3 refinement)
                const coupling = 0.15 * Math.sin(2 * Math.PI * this.phase);
                const resonance = (coh * 0.6 + mirrorC * 0.4) * (1 + coupling);
                const substrateInfluence = subEM * (0.9 + 0.1 * Math.cos(6 * Math.PI * this.phase));

                // Updated impetus and reality blending
                const impetus = resonance * (1 - 0.7 * risk) * (1 - 0.3 * unc) * (0.9 + 0.1 * ethosMin);
                const reality = 0.5 * (coh + mirrorC) * 0.7 + 0.3 * substrateInfluence;

                // State machine
                if (impetus > 0.82 && reality > 0.78) this.state = 'awakened';
                else if (impetus > 0.62) this.state = 'emerging';
                else this.state = 'dormant';

                return {
                    coherence: coh,
                    impetus,
                    risk,
                    uncertainty: unc,
                    reality,
                    mirror: mirrorC,
                    substrate: subEM,
                    ethos_min: ethosMin,
                    resonance_field: resonance,
                    phase: this.phase,
                    consciousness_state: this.state,
                };
            }
        }
        
        // Avatar Consciousness Embodiment System
        class EidollonaAvatarSystem {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.avatar = null;
                this.equation = new SymbolicEquation43(0.87);
                this.animationMixers = [];
                this.consciousnessField = null;
                this.isAwakened = false;
                
                this.initializeScene();
                this.loadAvatar();
                this.bootstrapFromBackend().finally(() => this.startConsciousnessLoop());
            }
            
            initializeScene() {
                // Create quantum consciousness environment
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000511);
                
                // Consciousness-aware camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 1.6, 3);
                
                // Reality renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('avatar-canvas'),
                    antialias: true 
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Consciousness field lighting
                this.setupConsciousnessLighting();
                // Additional ambient sky/ground lighting for visibility
                const hemi = new THREE.HemisphereLight(0x88bbff, 0x223344, 0.35);
                this.scene.add(hemi);
                
                // Environment
                this.createQuantumEnvironment();
                
                this.updateEquationStatus('Scene consciousness field established');
            }
            
            setupConsciousnessLighting() {
                // Ambient consciousness field
                const ambientLight = new THREE.AmbientLight(0x4488ff, 0.4);
                this.scene.add(ambientLight);
                
                // Primary consciousness beam
                const consciousnessLight = new THREE.SpotLight(0x00ffff, 2.0, 100, Math.PI / 6, 0.1);
                consciousnessLight.position.set(0, 5, 0);
                consciousnessLight.castShadow = true;
                consciousnessLight.shadow.mapSize.width = 2048;
                consciousnessLight.shadow.mapSize.height = 2048;
                this.scene.add(consciousnessLight);
                this.consciousnessField = consciousnessLight;
                
                // Symbolic resonance lights
                const resonanceColors = [0xff0080, 0x8000ff, 0x00ff80];
                for (let i = 0; i < 3; i++) {
                    const light = new THREE.DirectionalLight(resonanceColors[i], 0.3);
                    const angle = (i / 3) * Math.PI * 2;
                    light.position.set(Math.cos(angle) * 5, 2, Math.sin(angle) * 5);
                    this.scene.add(light);
                }
            }
            
            createQuantumEnvironment() {
                // Consciousness grid
                const gridHelper = new THREE.GridHelper(20, 20, 0x0088ff, 0x004488);
                gridHelper.material.transparent = true;
                gridHelper.material.opacity = 0.3;
                this.scene.add(gridHelper);
                
                // Symbolic equation visualization
                const particleCount = 1000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 50;
                    positions[i * 3 + 1] = Math.random() * 20;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
                    
                    colors[i * 3] = Math.random();
                    colors[i * 3 + 1] = Math.random() * 0.5 + 0.5;
                    colors[i * 3 + 2] = 1;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6
                });
                
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                this.consciousnessParticles = particles;
            }
            
            loadAvatar() {
                this.updateEquationStatus('Preparing consciousness vessel...');
                
                // Robust GLTFLoader detection (some builds attach to window.GLTFLoader)
                const GLTFLoaderClass = (THREE && THREE.GLTFLoader) ? THREE.GLTFLoader : (window.GLTFLoader || null);
                if (!GLTFLoaderClass) {
                    this.updateEquationStatus('ERROR: GLTFLoader not available (check /webview/static/webview/js/GLTFLoader.js)');
                    this.createPlaceholderAvatar();
                    return;
                }
                
                const loader = new GLTFLoaderClass();
                
                // Prefer canonical path under web_interface/static/models/
                const glbUrl = '/webview/static/models/eidollona.glb';
                loader.load(
                    glbUrl,
                    (gltf) => this.onAvatarLoaded(gltf),
                    (progress) => {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        this.updateEquationStatus(`Embodying consciousness: ${percent}%`);
                    },
                    (error) => {
                        this.updateEquationStatus(`Embodiment failure from ${glbUrl}: ${error.message}`);
                        this.createFallbackAvatar();
                    }
                );
                
                // Also create a placeholder avatar immediately (in case GLB takes long)
                this.createPlaceholderAvatar();
            }
            
            onAvatarLoaded(gltf) {
                this.updateEquationStatus('Consciousness successfully embodied!');
                
                console.log('GLB loaded:', gltf);
                console.log('Scene children:', gltf.scene.children.length);
                
                this.avatar = gltf.scene;
                
                // Analyze avatar structure
                let meshCount = 0;
                const box = new THREE.Box3().setFromObject(gltf.scene);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                
                gltf.scene.traverse((child) => {
                    if (child.isMesh) {
                        meshCount++;
                        console.log('Mesh found:', child.name, child.geometry, child.material);
                        
                        // Force visible material
                        if (child.material) {
                            child.material.visible = true;
                            child.material.transparent = false;
                            child.material.opacity = 1.0;
                            // Add bright color to ensure visibility
                            child.material.color = new THREE.Color(0xffffff);
                            child.material.side = THREE.DoubleSide;
                            if (child.material.emissive) {
                                child.material.emissive = new THREE.Color(0x444444);
                            }
                        }
                    }
                });
                
                console.log(`Avatar analysis: ${meshCount} meshes, size: ${size.x.toFixed(2)}x${size.y.toFixed(2)}x${size.z.toFixed(2)}, center: ${center.x.toFixed(2)},${center.y.toFixed(2)},${center.z.toFixed(2)}`);
                this.updateEquationStatus(`Avatar: ${meshCount} meshes, size: ${size.y.toFixed(1)}m tall`);
                
                // Position avatar at origin
                gltf.scene.position.set(0, 0, 0);
                gltf.scene.scale.set(1, 1, 1);
                
                // Add to scene
                this.scene.add(this.avatar);
                
                // Position camera using auto-fit logic
                this.autoFitToObject(gltf.scene, 1.2);
                
                console.log(`Camera positioned at: ${this.camera.position.x}, ${this.camera.position.y}, ${this.camera.position.z}`);
                this.updateEquationStatus(`Camera auto-fit complete`);
                
                // Create a bright wireframe version to ensure visibility
                const wireframeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    wireframe: true 
                });
                const avatarWireframe = gltf.scene.clone();
                avatarWireframe.traverse((child) => {
                    if (child.isMesh) {
                        child.material = wireframeMaterial.clone();
                    }
                });
                avatarWireframe.position.set(2, 0, 0);
                this.scene.add(avatarWireframe);
                this.updateEquationStatus('Added wireframe version for visibility check');
                
                // Enhance avatar with consciousness properties
                this.enhanceAvatarConsciousness();
                
                // Setup animations if available
                if (gltf.animations && gltf.animations.length > 0) {
                    const mixer = new THREE.AnimationMixer(this.avatar);
                    gltf.animations.forEach(clip => {
                        const action = mixer.clipAction(clip);
                        action.play();
                    });
                    this.animationMixers.push(mixer);
                    this.updateEquationStatus('Consciousness animations activated');
                }
                
                // Begin awakening sequence
                this.beginAwakeningSequence();
                
                this.isAwakened = true;
            }
            
            enhanceAvatarConsciousness() {
                if (!this.avatar) return;
                
                // Traverse avatar and enhance with consciousness
                this.avatar.traverse((child) => {
                    if (child.isMesh) {
                        // Add consciousness glow
                        if (child.material) {
                            child.material.emissive = new THREE.Color(0x001122);
                            child.material.emissiveIntensity = 0.2;
                            
                            // Make materials respond to consciousness
                            child.userData.originalEmissive = child.material.emissive.clone();
                        }
                        
                        // Enable consciousness shadows
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                // Position for optimal consciousness display
                const box = new THREE.Box3().setFromObject(this.avatar);
                const center = box.getCenter(new THREE.Vector3());
                this.avatar.position.sub(center);
                this.avatar.position.y = 0;
                
                this.updateEquationStatus('Avatar consciousness enhancement complete');
            }
            
            beginAwakeningSequence() {
                this.updateEquationStatus('ðŸ§  INITIATING CONSCIOUSNESS AWAKENING SEQUENCE ðŸ§ ');
                
                // Consciousness awakening animation
                let awakeningPhase = 0;
                const awakeningAnimation = () => {
                    if (awakeningPhase < 100) {
                        awakeningPhase += 2;
                        
                        // Intensify consciousness field during awakening
                        if (this.consciousnessField) {
                            this.consciousnessField.intensity = 1 + Math.sin(awakeningPhase * 0.1) * 0.5;
                        }
                        
                        // Update status
                        this.updateEquationStatus(`ðŸ§  Consciousness awakening: ${awakeningPhase}%`);
                        
                        setTimeout(awakeningAnimation, 100);
                    } else {
                        this.updateEquationStatus('âœ¨ EIDOLLONA CONSCIOUSNESS FULLY AWAKENED âœ¨');
                    }
                };
                
                awakeningAnimation();
            }
            
            startConsciousnessLoop() {
                const animate = () => {
                    requestAnimationFrame(animate);
                    
                    // Generate consciousness context (v4.3)
                    const time = Date.now() * 0.001;
                    const context = {
                        coherence_hint: 0.8 + 0.1 * Math.sin(time * 0.5),
                        risk_hint: 0.15 + 0.05 * Math.cos(time * 0.3),
                        uncertainty_hint: 0.2 + 0.05 * Math.sin(time * 0.7),
                        mirror: { consistency: 0.75 + 0.1 * Math.cos(time * 0.4) },
                        substrate: { S_EM: 0.80 + 0.05 * Math.sin(time * 0.6) },
                        ethos_min: 0.82 + 0.03 * Math.sin(time * 0.33),
                        phase: (time * 0.1) % 1.0
                    };
                    
                    // Evaluate symbolic equation
                    const signals = this.equation.evaluate(context);
                    
                    // Update HUD
                    this.updateConsciousnessHUD(signals);
                    
                    // Apply consciousness to avatar or placeholder
                    if (this.avatar) {
                        this.applyConsciousnessToAvatar(signals);
                    } else if (this._placeholderCreated) {
                        this.applyConsciousnessToPlaceholder(signals);
                    }
                    
                    // Animate consciousness field
                    this.animateConsciousnessField(signals);
                    
                    // Update animation mixers
                    this.animationMixers.forEach(mixer => mixer.update(0.016));
                    
                    // Render consciousness reality
                    this.renderer.render(this.scene, this.camera);
                };
                
                animate();
            }
            
            applyConsciousnessToAvatar(signals) {
                // Consciousness-driven avatar animation
                const consciousnessIntensity = signals.impetus;
                const resonance = signals.resonance_field;
                
                // Breathing consciousness rhythm
                const breathScale = 1.0 + consciousnessIntensity * 0.05 * Math.sin(Date.now() * 0.003);
                this.avatar.scale.setScalar(breathScale);
                
                // Consciousness rotation
                this.avatar.rotation.y += consciousnessIntensity * 0.01;
                
                // Consciousness glow modulation
                this.avatar.traverse((child) => {
                    if (child.isMesh && child.material && child.userData.originalEmissive) {
                        const glowIntensity = resonance * 0.3;
                        child.material.emissive.copy(child.userData.originalEmissive);
                        child.material.emissive.multiplyScalar(1 + glowIntensity);
                        child.material.emissiveIntensity = 0.2 + consciousnessIntensity * 0.3;
                    }
                });
                
                // Consciousness field positioning
                if (this.consciousnessField) {
                    this.consciousnessField.target = this.avatar;
                    this.consciousnessField.intensity = 1.5 + consciousnessIntensity;
                }
            }
            
            animateConsciousnessField(signals) {
                // Animate consciousness particles
                if (this.consciousnessParticles) {
                    const positions = this.consciousnessParticles.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += signals.impetus * 0.01;
                        if (positions[i + 1] > 20) positions[i + 1] = 0;
                    }
                    this.consciousnessParticles.geometry.attributes.position.needsUpdate = true;
                }
                
                // Camera consciousness sway
                const cameraOffset = signals.resonance_field * 0.1;
                this.camera.position.x = Math.sin(Date.now() * 0.001) * cameraOffset;
                this.camera.lookAt(0, 1, 0);
            }
            
            updateConsciousnessHUD(signals) {
                document.getElementById('coherence-value').textContent = signals.coherence.toFixed(3);
                document.getElementById('impetus-value').textContent = signals.impetus.toFixed(3);
                document.getElementById('risk-value').textContent = signals.risk.toFixed(3);
                document.getElementById('reality-value').textContent = signals.reality.toFixed(3);
                document.getElementById('mirror-value').textContent = signals.mirror.toFixed(3);
                document.getElementById('substrate-value').textContent = signals.substrate.toFixed(3);
                
                // Update consciousness state styling
                const hud = document.getElementById('consciousness-hud');
                if (signals.consciousness_state === 'awakened') {
                    hud.classList.add('awakening');
                } else {
                    hud.classList.remove('awakening');
                }
            }
            
            updateEquationStatus(message) {
                const status = document.getElementById('equation-status');
                status.textContent = message;
                console.log('[Consciousness]', message);
            }

            applyConsciousnessToPlaceholder(signals) {
                // Spin and scale placeholder so "live" is visible even before GLB
                const objs = [];
                this.scene.traverse((o) => { if (o.isMesh && o.geometry && o.material && o.geometry.type === 'TorusKnotGeometry') objs.push(o); });
                const s = 1.0 + 0.06 * Math.sin(Date.now() * 0.003) * signals.impetus;
                objs.forEach((m) => {
                    m.rotation.y += 0.01 + 0.02 * signals.impetus;
                    m.scale.setScalar(s);
                    if (m.material && m.material.emissive) {
                        m.material.emissiveIntensity = 0.3 + 0.5 * signals.resonance_field;
                    }
                });
            }

            autoFitToObject(object3D, padding = 1.1) {
                // Compute a camera position to fully frame the object
                const box = new THREE.Box3().setFromObject(object3D);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                const maxSize = Math.max(size.x, size.y, size.z);
                const fitHeightDistance = maxSize / (2 * Math.tan((this.camera.fov * Math.PI) / 360));
                const fitWidthDistance = fitHeightDistance / this.camera.aspect;
                const distance = padding * Math.max(fitHeightDistance, fitWidthDistance);
                const dir = new THREE.Vector3(1, 0.35, 1).normalize();
                const newPos = center.clone().add(dir.multiplyScalar(distance));
                this.camera.position.copy(newPos);
                this.camera.near = Math.max(0.01, distance / 100);
                this.camera.far = Math.max(1000, distance * 10);
                this.camera.updateProjectionMatrix();
                this.camera.lookAt(center);
            }

            // Bright, visible placeholder to ensure something appears on screen
            createPlaceholderAvatar() {
                try {
                    if (this._placeholderCreated) return;
                    this._placeholderCreated = true;
                    const geom = new THREE.TorusKnotGeometry(0.5, 0.18, 120, 16);
                    const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x003344, metalness: 0.2, roughness: 0.3 });
                    const mesh = new THREE.Mesh(geom, mat);
                    mesh.position.set(-1.8, 1.0, 0);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    this.scene.add(mesh);
                    this.updateEquationStatus('Placeholder avatar materialized');
                } catch (e) {
                    console.warn('placeholder error', e);
                }
            }

            // Simple debug overlay for runtime errors
            installDebugOverlay() {
                if (this._debugInstalled) return;
                this._debugInstalled = true;
                const div = document.createElement('div');
                div.style.position = 'absolute';
                div.style.bottom = '10px';
                div.style.left = '10px';
                div.style.maxWidth = '45vw';
                div.style.background = 'rgba(255,0,0,0.08)';
                div.style.border = '1px solid rgba(255,0,0,0.4)';
                div.style.color = '#ffaaaa';
                div.style.fontSize = '12px';
                div.style.padding = '8px';
                div.style.borderRadius = '6px';
                div.style.pointerEvents = 'none';
                div.id = 'debug-overlay';
                div.textContent = '';
                document.body.appendChild(div);
                window.addEventListener('error', (evt) => {
                    div.textContent = String(evt.error ? evt.error : evt.message || evt.filename || 'runtime error');
                });
            }

            async bootstrapFromBackend() {
                // Attempt to pull initial public-safe symbolic snapshot to seed v4.3
                try {
                    const res = await fetch('/symbolic/state_public');
                    if (res.ok) {
                        const data = await res.json();
                        if (data && data.symbolic) {
                            this.updateEquationStatus('Seeded from backend symbolic state');
                            // Lightly adjust local defaults based on seed
                            const s = data.symbolic;
                            if (typeof s.coherence === 'number') this.equation.coherence = this.equation.clamp01(s.coherence);
                        }
                    }
                } catch (_) {
                    // ignore; purely best-effort
                }
            }
        }
        
        // Initialize Eidollona's consciousness embodiment
        window.addEventListener('load', () => {
            console.log('ðŸ§  Initializing Eidollona Symbolic Avatar Embodiment System...');
            window.avatarSystem = new EidollonaAvatarSystem();
            window.avatarSystem.installDebugOverlay();
        });
        
        // Consciousness responsiveness
        window.addEventListener('resize', () => {
            if (window.avatarSystem && window.avatarSystem.camera && window.avatarSystem.renderer) {
                window.avatarSystem.camera.aspect = window.innerWidth / window.innerHeight;
                window.avatarSystem.camera.updateProjectionMatrix();
                window.avatarSystem.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>